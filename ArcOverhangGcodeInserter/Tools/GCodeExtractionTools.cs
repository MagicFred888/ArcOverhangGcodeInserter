using ArcOverhangGcodeInserter.Info;
using ArcOverhangGcodeInserter.Tools;
using System.Text.RegularExpressions;

namespace ArcOverhangGcodeInserter.Class;

public partial class GCodeExtractionTools : IDisposable
{
    private enum SlicerType
    {
        PrusaSlicer,
        BambuLab
    }

    [GeneratedRegex(@"^G[123] X.+?Y")]
    private static partial Regex ValidGmoveRegex();

    [GeneratedRegex(@"^G[123] X.+?Y.+?E\d*\.\d+$")]
    private static partial Regex ValidGmoveWithExtrusionRegex();

    private bool disposedValue;
    private readonly ThreeDimensionalPrintInfo parent;
    private readonly List<string> fullGCode;
    private readonly SlicerType slicerType;
    private readonly string layerHeightKey;
    private readonly string layerZPositionKey;

    private readonly Dictionary<string, PathType> objectToExtract = [];
    private readonly string newLayerStartComment;
    private readonly string lastLayerEndComment;
    private readonly string startOverhangWallComment;
    private readonly string startFeatureCommentStart;
    private readonly string startWipeComment;
    private readonly string newZHeightCommentStart;

    public GCodeExtractionTools(ThreeDimensionalPrintInfo parent, List<string> fullGCode)
    {
        // Check null parameters
        ArgumentNullException.ThrowIfNull(parent);
        ArgumentNullException.ThrowIfNull(fullGCode);

        // Save parameters
        this.parent = parent;
        this.fullGCode = fullGCode;

        // Check if G-Code is from PrusaSlicer or BambuLab
        slicerType = fullGCode[0].Contains("; generated by PrusaSlicer") ? SlicerType.PrusaSlicer : SlicerType.BambuLab;

        // Set basic search parameters
        if (slicerType == SlicerType.BambuLab)
        {
            // Features type
            objectToExtract.Add("; FEATURE: Outer wall", PathType.OuterWall);
            objectToExtract.Add("; FEATURE: Inner wall", PathType.InnerWall);
            objectToExtract.Add("; FEATURE: Bridge", PathType.OverhangArea);
            objectToExtract.Add("; FEATURE: Overhang wall", PathType.UnknownOverhangWall);

            // Reference comments
            newLayerStartComment = "; CHANGE_LAYER";
            lastLayerEndComment = "; close powerlost recovery";
            startOverhangWallComment = "; FEATURE: Overhang wall";
            startFeatureCommentStart = "; FEATURE:";
            startWipeComment = "; WIPE_START";
            newZHeightCommentStart = "; Z_HEIGHT: ";

            // Layer extraction
            layerHeightKey = "; LAYER_HEIGHT: ";
            layerZPositionKey = "; Z_HEIGHT: ";
        }
        else if (slicerType == SlicerType.PrusaSlicer)
        {
            // Features type
            objectToExtract.Add(";TYPE:External perimeter", PathType.OuterWall);
            objectToExtract.Add(";TYPE:Perimeter", PathType.InnerWall);
            objectToExtract.Add(";TYPE:Bridge infill", PathType.OverhangArea);
            objectToExtract.Add(";TYPE:Overhang perimeter", PathType.UnknownOverhangWall);

            // Reference comments
            newLayerStartComment = ";LAYER_CHANGE";
            lastLayerEndComment = "; Filament-specific end gcode";
            startOverhangWallComment = "Not existing";
            startFeatureCommentStart = ";TYPE:";
            startWipeComment = ";WIPE_START";
            newZHeightCommentStart = ";Z:";

            // Layer extraction
            layerHeightKey = ";HEIGHT:";
            layerZPositionKey = ";Z:";
        }
        else
        {
            throw new InvalidDataException("Unable to determine slicer type");
        }
    }

    public float GetLayerZPos(List<string> layerGCode)
    {
        string? gCodeLine = layerGCode.Find(c => c.StartsWith(layerZPositionKey));
        if (string.IsNullOrEmpty(gCodeLine))
        {
            throw new InvalidDataException("Unable to find layer position");
        }
        return float.Parse(gCodeLine.Replace(layerZPositionKey, "").Trim());
    }

    public float GetLayerHeight(List<string> layerGCode)
    {
        string? gCodeLine = layerGCode.Find(c => c.StartsWith(layerHeightKey));
        if (string.IsNullOrEmpty(gCodeLine))
        {
            throw new InvalidDataException("Unable to find layer height");
        }
        return float.Parse(gCodeLine.Replace(layerHeightKey, "").Trim());
    }

    public List<LayerInfo> ExtractAllLayerInfoFromGCode()
    {
        Dictionary<int, (List<string> gCode, List<PathInfo> paths)> extraction = ExtractRawDataFromGCode(fullGCode);

        // Create all layer objects
        List<LayerInfo> result = [];
        for (int layerId = 1; layerId <= extraction.Count; layerId++)
        {
            // Fix path type
            List<PathInfo> fixedPaths = FixUnknownOverhangWall(extraction[layerId].paths);

            // Create new layer and add in list
            LayerInfo newLayer = new(parent, layerId, extraction[layerId].gCode, fixedPaths, result.Count != 0 ? result[^1] : null);
            result.Add(newLayer);
        }

        // Clean path by removing all extrusion not made at current reference layer
        return result;
    }

    private static List<PathInfo> FixUnknownOverhangWall(List<PathInfo> paths)
    {
        for (int pos = 0; pos < paths.Count; pos++)
        {
            PathInfo path = paths[pos];
            if (path.Type == PathType.UnknownOverhangWall)
            {
                if (pos < paths.Count - 1 && paths[pos + 1].Type == PathType.UnknownOverhangWall)
                {
                    path.Type = PathType.InnerOverhangWall;
                    paths[pos + 1].Type = PathType.OuterOverhangWall;
                }
                else
                {
                    paths[pos].Type = PathType.OuterOverhangWall;
                }
            }
        }
        return paths;
    }

    private Dictionary<int, (List<string> gCode, List<PathInfo> paths)> ExtractRawDataFromGCode(List<string> fullGCode)
    {
        // For result
        Dictionary<int, (List<string> gCode, List<PathInfo>)> result = [];

        // Variables used to extract layers
        int layerNumber = 0;
        int startLayerPos = 0;
        string zHeight = string.Empty;

        // Cariables used to extract features
        PathType currentPathType = PathType.Unknown;
        bool isOverhang = false;
        PathInfo currentPath = new(PathType.Unknown);
        List<PathInfo> currentLayerData = [];
        PointF startPosition = PointF.Empty;

        // Full G-code scan
        for (int lineNbr = 1; lineNbr < fullGCode.Count; lineNbr++)
        {
            // Extract line
            string line = fullGCode[lineNbr - 1];

            // Check if new layer
            if (line.Equals(newLayerStartComment) || line.Equals(lastLayerEndComment))
            {
                // Check if we have an open path
                if (currentPath.AllSegments.Count > 0)
                {
                    currentPath.FullGCodeEndLine = lineNbr - 1;
                    currentLayerData.Add(currentPath);
                }

                // Save current layer
                if (currentLayerData.Count > 0)
                {
                    result.Add(layerNumber, (fullGCode.GetRange(startLayerPos - 1, lineNbr - startLayerPos), currentLayerData));
                }

                // End of the part
                if (line.Equals(lastLayerEndComment))
                {
                    break;
                }

                // New layer
                layerNumber = result.Count + 1;
                startLayerPos = lineNbr;
                currentPath = new(PathType.Unknown);
                currentLayerData = [];
                currentPathType = PathType.Unknown;
                continue;
            }

            if (line.StartsWith(newZHeightCommentStart))
            {
                zHeight = $" Z{float.Parse(line.Replace(newZHeightCommentStart, "").Trim()):#.#} ";
            }

            // Valid layer
            if (layerNumber <= 0)
            {
                continue;
            }

            // Check if overhang
            if (line.StartsWith(startFeatureCommentStart))
            {
                isOverhang = line.Equals(startOverhangWallComment) || currentPathType == PathType.OverhangArea;
            }

            // Switch type except if we get an overhang wall within an inner or outer wall
            if (line.StartsWith(startFeatureCommentStart))
            {
                if (line.Equals(startOverhangWallComment) && (currentPathType == PathType.InnerWall || currentPathType == PathType.OuterWall))
                {
                    continue;
                }
                if (objectToExtract.TryGetValue(line, out PathType newPathType))
                {
                    currentPathType = newPathType;
                }
                else
                {
                    currentPathType = PathType.Unknown;
                }
            }

            // Keep last valid G-code move to get starting point
            bool isValidMove = ValidGmoveRegex().IsMatch(line);
            bool isValidMoveWithExtrusion = ValidGmoveWithExtrusionRegex().IsMatch(line);
            if (isValidMove && !isValidMoveWithExtrusion)
            {
                startPosition = GCodeTools.GetXYFromGCode(line);
            }

            // Add valid move
            if (isValidMoveWithExtrusion && currentPathType != PathType.Unknown)
            {
                if (!line.Contains(" Z") || line.Contains(zHeight))
                {
                    if (currentPath.Type == PathType.Unknown)
                    {
                        currentPath.Type = currentPathType;
                        currentPath.FullGCodeStartLine = lineNbr;
                    }
                    currentPath.AddSegmentInfo(new SegmentInfo(lineNbr, startPosition, line, isOverhang));
                }
                startPosition = GCodeTools.GetXYFromGCode(line);
                continue;
            }

            // Unknown path ?
            if (currentPath.Type == PathType.Unknown)
            {
                continue;
            }

            // End of a path?
            if ((isValidMove && !isValidMoveWithExtrusion)
                || (currentPath.Type != PathType.OverhangArea
                   && (line.StartsWith(startWipeComment) || line.StartsWith(startFeatureCommentStart) && !line.Equals(startOverhangWallComment) && currentPath.Type != currentPathType)))
            {
                currentPath.FullGCodeEndLine = lineNbr - 1;
                currentLayerData.Add(currentPath);
                currentPath = new(PathType.Unknown);
            }
        }

        // Done
        return result;
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                // Dispose managed state (managed objects) if any
            }
            fullGCode.Clear();
            objectToExtract.Clear();
            disposedValue = true;
        }
    }

    public void Dispose()
    {
        // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }
}